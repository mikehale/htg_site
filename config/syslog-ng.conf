#
# Configuration file for syslog-ng under Debian
#
# attempts at reproducing default syslog behavior

# the standard syslog levels are (in descending order of priority):
# emerg alert crit err warning notice info debug
# the aliases "error", "panic", and "warn" are deprecated
# the "none" priority found in the original syslogd configuration is
# only used in internal messages created by syslogd


######
# options

options {
        # disable the chained hostname format in logs
        # (default is enabled)
        chain_hostnames(0);

        # the time to wait before a died connection is re-established
        # (default is 60)
        time_reopen(10);

        # the time to wait before an idle destination file is closed
        # (default is 60)
        time_reap(360);

        # the number of lines buffered before written to file
        # you might want to increase this if your disk isn't catching with
        # all the log messages you get or if you want less disk activity
        # (say on a laptop)
        # (default is 0)
        #sync(0);

        # the number of lines fitting in the output queue
        log_fifo_size(2048);

        # enable or disable directory creation for destination files
        create_dirs(yes);

        # default owner, group, and permissions for log files
        # (defaults are 0, 0, 0600)
        #owner(root);
        group(adm);
        perm(0640);

        # default owner, group, and permissions for created directories
        # (defaults are 0, 0, 0700)
        #dir_owner(root);
        #dir_group(root);
        dir_perm(0755);

        # enable or disable DNS usage
        # syslog-ng blocks on DNS queries, so enabling DNS may lead to
        # a Denial of Service attack
        # (default is yes)
        #use_dns(no);

        # maximum length of message in bytes
        # this is only limited by the program listening on the /dev/log Unix
        # socket, glibc can handle arbitrary length log messages, but -- for
        # example -- syslogd accepts only 1024 bytes
        # (default is 2048)
        #log_msg_size(2048);

	#Disable statistic log messages.
	stats_freq(0);

	# Some program send log messages through a private implementation.
	# and sometimes that implementation is bad. If this happen syslog-ng
	# may recognise the program name as hostname. Whit this option
	# we tell the syslog-ng that if a hostname match this regexp than that
	# is not a real hostname.
	bad_hostname("^gconfd$");
};


######
# sources

# all known message sources
source s_all {
	# message generated by Syslog-NG
	internal();
	# standard Linux log source (this is the default place for the syslog()
	# function to send logs to)
	unix-stream("/dev/log");
	# messages from the kernel
	file("/proc/kmsg" log_prefix("kernel: "));
	# use the following line if you want to receive remote UDP logging messages
	# (this is equivalent to the "-r" syslogd flag)
	# udp();

	# read from named pipes (using mkfifo to create a named pipe) 
	# for programs that don't have native syslog support
	pipe("/var/log/nginx/fifo/site_access" log_prefix("nginx_site_access: "));
	pipe("/var/log/nginx/fifo/site_error" log_prefix("nginx_site_error: "));
};

######
# templates

template t_default { template("$ISODATE <$FACILITY.$PRIORITY> $HOST $MSG\n"); template_escape(no); };

######
# destinations

# some standard log files
# destination df_auth { file("/var/log/auth"); };
destination df_auth {	file("/var/log/archive/auth/$R_YEAR/$R_MONTH/$R_YEAR-$R_MONTH-$R_DAY" template(t_default)); };

# destination df_syslog { file("/var/log/syslog"); };
destination df_syslog {	file("/var/log/archive/syslog/$R_YEAR/$R_MONTH/$R_YEAR-$R_MONTH-$R_DAY" template(t_default)); };

#destination df_cron { file("/var/log/cron.log"); };
destination df_cron {	file("/var/log/archive/cron/$R_YEAR/$R_MONTH/$R_YEAR-$R_MONTH-$R_DAY" template(t_default)); };

#destination df_daemon { file("/var/log/daemon.log"); };
destination df_daemon {	file("/var/log/archive/daemon/$R_YEAR/$R_MONTH/$R_YEAR-$R_MONTH-$R_DAY" template(t_default)); };

#destination df_kern { file("/var/log/kern.log"); };
destination df_kern {	file("/var/log/archive/kern/$R_YEAR/$R_MONTH/$R_YEAR-$R_MONTH-$R_DAY" template(t_default)); };

# destination df_lpr { file("/var/log/lpr.log"); };
destination df_lpr {	file("/var/log/archive/lpr/$R_YEAR/$R_MONTH/$R_YEAR-$R_MONTH-$R_DAY" template(t_default)); };

# destination df_mail { file("/var/log/mail.log"); };
destination df_mail {	file("/var/log/archive/mail/$R_YEAR/$R_MONTH/$R_YEAR-$R_MONTH-$R_DAY" template(t_default)); };

# destination df_user { file("/var/log/user.log"); };
destination df_user {	file("/var/log/archive/user/$R_YEAR/$R_MONTH/$R_YEAR-$R_MONTH-$R_DAY" template(t_default)); };

# destination df_uucp { file("/var/log/uucp.log"); };
destination df_uucp {	file("/var/log/archive/uucp/$R_YEAR/$R_MONTH/$R_YEAR-$R_MONTH-$R_DAY" template(t_default)); };

# these files are meant for the mail system log files
# and provide re-usable destinations for {mail,cron,...}.info,
# {mail,cron,...}.notice, etc.

# destination df_facility_dot_info { file("/var/log/$FACILITY.info"); };
destination df_facility_dot_info { file("/var/log/archive/$FACILITY.info/$R_YEAR/$R_MONTH/$R_YEAR-$R_MONTH-$R_DAY" template(t_default)); };

# destination df_facility_dot_notice { file("/var/log/$FACILITY.notice"); };
destination df_facility_dot_notice { file("/var/log/archive/$FACILITY.notice/$R_YEAR/$R_MONTH/$R_YEAR-$R_MONTH-$R_DAY" template(t_default)); };

# destination df_facility_dot_warn { file("/var/log/$FACILITY.warn"); };
destination df_facility_dot_warn { file("/var/log/archive/$FACILITY.warn/$R_YEAR/$R_MONTH/$R_YEAR-$R_MONTH-$R_DAY" template(t_default)); };

# destination df_facility_dot_err { file("/var/log/$FACILITY.err"); };
destination df_facility_dot_err { file("/var/log/archive/$FACILITY.err/$R_YEAR/$R_MONTH/$R_YEAR-$R_MONTH-$R_DAY" template(t_default)); };

# destination df_facility_dot_crit { file("/var/log/$FACILITY.crit"); };
destination df_facility_dot_crit { file("/var/log/archive/$FACILITY.crit/$R_YEAR/$R_MONTH/$R_YEAR-$R_MONTH-$R_DAY" template(t_default)); };

# some more classical and useful files found in standard syslog configurations
# destination df_debug { file("/var/log/debug"); };
destination df_debug { file("/var/log/archive/debug/$R_YEAR/$R_MONTH/$R_YEAR-$R_MONTH-$R_DAY" template(t_default)); };

# pipes
# a console to view log messages under X
destination dp_xconsole { pipe("/dev/xconsole"); };

# consoles
# this will send messages to everyone logged in
destination du_all { usertty("*"); };


######
# filters

# all messages from the auth and authpriv facilities
filter f_auth { facility(auth, authpriv); };

# all messages except from the auth and authpriv facilities
filter f_syslog { not facility(auth, authpriv); };

# respectively: messages from the cron, daemon, kern, lpr, mail, news, user,
# and uucp facilities
filter f_cron { facility(cron); };
filter f_daemon { facility(daemon); };
filter f_kern { facility(kern); };
filter f_lpr { facility(lpr); };
filter f_mail { facility(mail); };
filter f_user { facility(user); };
filter f_uucp { facility(uucp); };

# some filters to select messages of priority greater or equal to info, warn,
# and err
# (equivalents of syslogd's *.info, *.warn, and *.err)
filter f_at_least_info { level(info..emerg); };
filter f_at_least_notice { level(notice..emerg); };
filter f_at_least_warn { level(warn..emerg); };
filter f_at_least_err { level(err..emerg); };
filter f_at_least_crit { level(crit..emerg); };

# all messages of priority debug not coming from the auth, authpriv, news, and
# mail facilities
filter f_debug { level(debug) and not facility(auth, authpriv, news, mail); };

# all messages of info, notice, or warn priority not coming form the auth,
# authpriv, cron, daemon, mail, and news facilities

# messages with priority emerg
filter f_emerg { level(emerg); };

# complex filter for messages usually sent to the xconsole
filter f_xconsole {
    facility(daemon,mail)
        or level(debug,info,notice,warn)
        or (facility(news)
                and level(crit,err,notice));
};

# nginx logs
filter f_nginx { match("nginx"); };
filter f_not_nginx { not filter(f_nginx); };

# access and error logs
filter f_access { match("access"); };
filter f_error { match("error"); };

# Rails app logs
filter f_site { program("rails") or (match("rails") and facility(user)); };

######
# logs
# order matters if you use "flags(final);" to mark the end of processing in a
# "log" statement

# these rules provide the same behavior as the commented original syslogd rules

# auth,authpriv.*                 /var/log/auth.log
log {
        source(s_all);
        filter(f_auth);
        destination(df_auth);
};

# *.*;auth,authpriv.none          -/var/log/syslog
log {
        source(s_all);
        filter(f_syslog);
        filter(f_not_nginx);
        destination(df_syslog);
};

# this is commented out in the default syslog.conf
# cron.*                         /var/log/cron.log
#log {
#        source(s_all);
#        filter(f_cron);
#        destination(df_cron);
#};

# daemon.*                        -/var/log/daemon.log
log {
        source(s_all);
        filter(f_daemon);
        destination(df_daemon);
};

# kern.*                          -/var/log/kern.log
log {
        source(s_all);
        filter(f_kern);
        destination(df_kern);
};

# lpr.*                           -/var/log/lpr.log
log {
        source(s_all);
        filter(f_lpr);
        destination(df_lpr);
};

# mail.*                          -/var/log/mail.log
log {
        source(s_all);
        filter(f_mail);
        destination(df_mail);
};

# user.*                          -/var/log/user.log
log {
        source(s_all);
        filter(f_user);
        filter(f_not_nginx);
        destination(df_user);
};

# uucp.*                          /var/log/uucp.log
log {
        source(s_all);
        filter(f_uucp);
        destination(df_uucp);
};

# mail.info                       -/var/log/mail.info
log {
        source(s_all);
        filter(f_mail);
        filter(f_at_least_info);
        destination(df_facility_dot_info);
};

# mail.warn                       -/var/log/mail.warn
log {
        source(s_all);
        filter(f_mail);
        filter(f_at_least_warn);
        destination(df_facility_dot_warn);
};

# mail.err                        /var/log/mail.err
log {
        source(s_all);
        filter(f_mail);
        filter(f_at_least_err);
        destination(df_facility_dot_err);
};


# *.=debug;\
#         auth,authpriv.none;\
#         news.none;mail.none     -/var/log/debug
log {
        source(s_all);
        filter(f_debug);
        destination(df_debug);
};


# *.emerg                         *
log {
        source(s_all);
        filter(f_emerg);
        destination(du_all);
};


# daemon.*;mail.*;\
#         news.crit;news.err;news.notice;\
#         *.=debug;*.=info;\
#         *.=notice;*.=warn       |/dev/xconsole
log {
        source(s_all);
        filter(f_xconsole);
        destination(dp_xconsole);
};

#destination loghost { tcp("hs.hales.ws" port(601)); };
# send everything to loghost, too
#log {
#	source(s_all);
#	destination(loghost);
#};

destination df_htg_site_rails { file("/var/log/archive/apps/htg_site/$R_YEAR/$R_MONTH/$R_YEAR-$R_MONTH-$R_DAY.rails" template(t_default)); };
destination df_htg_site_access { file("/var/log/archive/apps/htg_site/$R_YEAR/$R_MONTH/$R_YEAR-$R_MONTH-$R_DAY.access" template(t_default)); };
destination df_htg_site_error { file("/var/log/archive/apps/htg_site/$R_YEAR/$R_MONTH/$R_YEAR-$R_MONTH-$R_DAY.error" template(t_default)); };

log {
	source(s_all);
	filter(f_site); filter(f_not_nginx);
	destination(df_htg_site_rails);
};

log {
	source(s_all);
	filter(f_site);	filter(f_nginx); filter(f_access);
	destination(df_htg_site_access);
};

log {
	source(s_all);
	filter(f_site);	filter(f_nginx); filter(f_error);
	destination(df_htg_site_error);
};
